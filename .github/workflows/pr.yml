name: PR Checks

on:
  pull_request:
    branches:
      - master
      - release/**
    types:
      - opened
      - synchronize
      - reopened
      - edited

jobs:
  check-status-go-submodule:
    name: Check status-go submodule branch
    runs-on: ubuntu-latest
    steps:
      - name: Get submodule commits and check if changed using GitHub API
        id: statusgo
        run: |
          # Get status-go submodule commit from PR head using GitHub API
          PR_RESPONSE=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/contents/vendor/status-go?ref=${{ github.head_ref }}")
          PR_COMMIT=$(echo "$PR_RESPONSE" | jq -r '.sha // empty')
          
          if [[ -z "$PR_COMMIT" ]]; then
            echo "::error::Failed to get status-go submodule commit from PR head"
            exit 1
          fi
          
          echo "commit=$PR_COMMIT" >> $GITHUB_OUTPUT
          echo "[LOG] status-go submodule commit in PR: $PR_COMMIT"
          
          # Get status-go submodule commit from base branch using GitHub API
          BASE_RESPONSE=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/contents/vendor/status-go?ref=${{ github.base_ref }}")
          BASE_COMMIT=$(echo "$BASE_RESPONSE" | jq -r '.sha // empty')
          
          if [[ -z "$BASE_COMMIT" ]]; then
            echo "::error::Failed to get status-go submodule commit from base branch"
            exit 1
          fi
          
          echo "base_commit=$BASE_COMMIT" >> $GITHUB_OUTPUT
          echo "[LOG] status-go submodule commit in base: $BASE_COMMIT"
          
          # Check if submodule changed
          if [[ "$PR_COMMIT" != "$BASE_COMMIT" ]]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "[LOG] status-go submodule changed in this PR."
          else
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "[LOG] status-go submodule NOT changed in this PR - skipping validation steps."
          fi

      - name: Get branches containing status-go commit using GitHub API
        if: steps.statusgo.outputs.changed == 'true'
        id: branches
        run: |
          STATUS_GO_COMMIT="${{ steps.statusgo.outputs.commit }}"
          echo "[LOG] Finding branches containing commit: $STATUS_GO_COMMIT"
          
          # Get all branches from status-go repository
          BRANCHES_RESPONSE=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/status-im/status-go/branches?per_page=100")
          
          # Check which branches contain the commit
          containing_branches=""
          for branch in $(echo "$BRANCHES_RESPONSE" | jq -r '.[].name'); do
            # Skip checking if we only need specific branches based on target
            if [[ "${{ github.base_ref }}" == "master" ]] && [[ "$branch" != "develop" ]]; then
              continue
            fi
            if [[ "${{ github.base_ref }}" == release/* ]] && [[ "$branch" != release/* ]] && [[ "$branch" != "develop" ]]; then
              continue
            fi
            
            # Check if commit is in this branch using compare API
            COMPARE_RESPONSE=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/status-im/status-go/compare/$branch...$STATUS_GO_COMMIT" 2>/dev/null || echo '{"status":"diverged"}')
            
            STATUS=$(echo "$COMPARE_RESPONSE" | jq -r '.status // "unknown"')
            if [[ "$STATUS" == "identical" ]] || [[ "$STATUS" == "behind" ]]; then
              containing_branches="$containing_branches$branch"$'\n'
              echo "[LOG] Commit found in branch: $branch"
            fi
          done
          
          echo "branches<<EOF" >> $GITHUB_OUTPUT
          echo "$containing_branches" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "[LOG] status-go commit is contained in branches:"
          echo "$containing_branches"

      - name: Validate status-go branch policy for master
        if: steps.statusgo.outputs.changed == 'true' && github.base_ref == 'master'
        run: |
          BRANCHES="${{ steps.branches.outputs.branches }}"
          echo "[LOG] Checking branch policy for master branch"
          if ! echo "$BRANCHES" | grep -x 'develop'; then
            echo "::error::status-go submodule must point to a commit on 'develop' branch when PR targets master."
            exit 1
          fi
          echo "[LOG] status-go commit is on develop branch."

      - name: Validate status-go branch policy for release
        if: steps.statusgo.outputs.changed == 'true' && startsWith(github.base_ref, 'release/')
        run: |
          BRANCHES="${{ steps.branches.outputs.branches }}"
          echo "[LOG] Checking branch policy for release branch: ${{ github.base_ref }}"
          if ! echo "$BRANCHES" | grep -E '^release/' >/dev/null; then
            echo "::error::status-go submodule must point to a commit on 'release/*' branch when PR targets a release branch."
            exit 1
          fi
          echo "[LOG] status-go commit is on a release/* branch."

      - name: Validate status-go commit recency using GitHub API
        if: steps.statusgo.outputs.changed == 'true'
        run: |
          STATUS_GO_COMMIT="${{ steps.statusgo.outputs.commit }}"
          BASE_COMMIT="${{ steps.statusgo.outputs.base_commit }}"
          echo "[LOG] Checking commit recency: PR=$STATUS_GO_COMMIT, base=$BASE_COMMIT"
          
          # Skip check if commits are identical
          if [[ "$STATUS_GO_COMMIT" == "$BASE_COMMIT" ]]; then
            echo "[LOG] status-go commits are identical. Skipping recency check."
            exit 0
          fi
          
          # Use GitHub API to compare commits instead of git operations
          COMPARE_RESPONSE=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/status-im/status-go/compare/$BASE_COMMIT...$STATUS_GO_COMMIT")
          
          STATUS=$(echo "$COMPARE_RESPONSE" | jq -r '.status // "unknown"')
          
          case "$STATUS" in
            "identical"|"ahead")
              echo "[LOG] status-go commit is newer than or equal to base branch. OK."
              ;;
            "behind")
              echo "::error::status-go submodule commit in PR is older than the one on the base branch."
              exit 1
              ;;
            "diverged")
              # For diverged commits, we need to check if base is ancestor of PR commit
              # This requires a more complex check, but we can use merge-base via API
              echo "[LOG] Commits have diverged, checking ancestry..."
              MERGE_BASE_RESPONSE=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                "https://api.github.com/repos/status-im/status-go/compare/$BASE_COMMIT...$STATUS_GO_COMMIT")
              
              # If we can find a path from base to PR commit, it's valid
              AHEAD_BY=$(echo "$MERGE_BASE_RESPONSE" | jq -r '.ahead_by // 0')
              if [[ "$AHEAD_BY" -gt 0 ]]; then
                echo "[LOG] status-go commit is ahead of base branch. OK."
              else
                echo "::error::status-go submodule commit in PR is not ahead of base branch."
                exit 1
              fi
              ;;
            *)
              echo "::warning::Unable to determine commit relationship (status: $STATUS). Skipping recency check."
              ;;
          esac