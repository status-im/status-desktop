import NimQml, json, stew/shims/strformat, sequtils, strutils, stint, strutils
import options

import backend/collectibles as backend
import collectible_trait_model
import collectible_ownership_model
import app_service/service/community_tokens/dto/community_token
import app_service/common/types

const invalidTimestamp* = high(int)

# Additional data needed to build an Entry, which is
# not included in the backend data and needs to be
# fetched from a different source.
type ExtraData* = object
  networkShortName*: string
  networkColor*: string
  networkIconURL*: string

# It is used to display a detailed collectibles entry in the QML UI
QtObject:
  type CollectiblesEntry* = ref object of QObject
    id: backend.CollectibleUniqueID
    data: backend.Collectible
    extradata: ExtraData
    traits: TraitModel
    ownership: OwnershipModel
    generatedId: string
    generatedCollectionId: string
    tokenType: TokenType

  proc setup(self: CollectiblesEntry) =
    self.QObject.setup

  proc delete*(self: CollectiblesEntry) =
    self.QObject.delete

  proc setData(self: CollectiblesEntry, data: backend.Collectible) =
    self.data = data
    self.traits = newTraitModel()
    self.ownership = newOwnershipModel()
    if isSome(data.collectibleData) and isSome(data.collectibleData.get().traits):
      let traits = data.collectibleData.get().traits.get()
      self.traits.setItems(traits)
    if isSome(data.ownership):
      let ownership = data.ownership.get()
      self.ownership.setItems(ownership)
    self.setup()

  proc `$`*(self: CollectiblesEntry): string =
    return
      fmt"""CollectiblesEntry(
      id:{self.id},
      data:{self.data},
      extradata:{self.extradata},
      traits:{self.traits},
      ownership:{self.ownership},
      generatedId:{self.generatedId},
      generatedCollectionId:{self.generatedCollectionId},
      tokenType:{self.tokenType},
    )"""

  proc hasCollectibleData(self: CollectiblesEntry): bool =
    return self.data != nil and isSome(self.data.collectibleData)

  proc getCollectibleData*(self: CollectiblesEntry): backend.CollectibleData =
    return self.data.collectibleData.get()

  proc hasCollectionData(self: CollectiblesEntry): bool =
    return self.data != nil and isSome(self.data.collectionData)

  proc getCollectionData(self: CollectiblesEntry): backend.CollectionData =
    return self.data.collectionData.get()

  proc hasCommunityData*(self: CollectiblesEntry): bool =
    return self.data != nil and isSome(self.data.communityData)

  proc getCommunityData*(self: CollectiblesEntry): backend.CommunityData =
    return self.data.communityData.get()

  proc hasOwnership(self: CollectiblesEntry): bool =
    return self.data != nil and isSome(self.data.ownership)

  proc getOwnership(self: CollectiblesEntry): seq[backend.AccountBalance] =
    return self.data.ownership.get()

  proc getChainID*(self: CollectiblesEntry): int {.slot.} =
    return self.id.contractID.chainID

  QtProperty[int] chainId:
    read = getChainID

  proc getContractAddress*(self: CollectiblesEntry): string {.slot.} =
    return self.id.contractID.address

  QtProperty[string] contractAddress:
    read = getContractAddress

  proc getTokenID*(self: CollectiblesEntry): UInt256 =
    return self.id.tokenID

  proc getTokenIDAsString*(self: CollectiblesEntry): string {.slot.} =
    return self.getTokenID().toString()

  QtProperty[string] tokenId:
    read = getTokenIDAsString

  # Unique ID to identify collectible, generated by us
  proc getID*(self: CollectiblesEntry): backend.CollectibleUniqueID =
    return self.id

  proc getIDAsString*(self: CollectiblesEntry): string =
    return self.generatedId

  # Unique ID to identify collection, generated by us
  proc getCollectionID*(self: CollectiblesEntry): backend.ContractID =
    return self.id.contractID

  proc getCollectionIDAsString*(self: CollectiblesEntry): string =
    return self.generatedCollectionId

  proc nameChanged*(self: CollectiblesEntry) {.signal.}
  proc getName*(self: CollectiblesEntry): string {.slot.} =
    if self.hasCollectibleData():
      result = self.data.collectibleData.get().name
    if result == "":
      result = "#" & self.getTokenIDAsString()

  QtProperty[string] name:
    read = getName
    notify = nameChanged

  proc imageURLChanged*(self: CollectiblesEntry) {.signal.}
  proc getImageURL*(self: CollectiblesEntry): string {.slot.} =
    if not self.hasCollectibleData() or isNone(self.getCollectibleData().imageUrl):
      return ""
    return self.getCollectibleData().imageUrl.get()

  QtProperty[string] imageUrl:
    read = getImageURL
    notify = imageURLChanged

  proc getOriginalMediaURL(self: CollectiblesEntry): string =
    if not self.hasCollectibleData() or isNone(self.getCollectibleData().animationUrl):
      return ""
    return self.getCollectibleData().animationUrl.get()

  proc mediaURLChanged*(self: CollectiblesEntry) {.signal.}
  proc getMediaURL*(self: CollectiblesEntry): string {.slot.} =
    result = self.getOriginalMediaURL()
    if result == "":
      result = self.getImageURL()

  QtProperty[string] mediaUrl:
    read = getMediaURL
    notify = mediaURLChanged

  proc getOriginalMediaType(self: CollectiblesEntry): string =
    if not self.hasCollectibleData() or
        isNone(self.getCollectibleData().animationMediaType):
      return ""
    return self.getCollectibleData().animationMediaType.get()

  proc mediaTypeChanged*(self: CollectiblesEntry) {.signal.}
  proc getMediaType*(self: CollectiblesEntry): string {.slot.} =
    result = self.getOriginalMediaType()
    if result == "":
      result = "image"

  QtProperty[string] mediaType:
    read = getMediaType
    notify = mediaTypeChanged

  proc backgroundColorChanged*(self: CollectiblesEntry) {.signal.}
  proc getBackgroundColor*(self: CollectiblesEntry): string {.slot.} =
    var color = "transparent"
    if self.hasCollectibleData() and isSome(self.getCollectibleData().backgroundColor):
      let backgroundColor = self.getCollectibleData().backgroundColor.get()
      if backgroundColor != "":
        color = "#" & backgroundColor
    return color

  QtProperty[string] backgroundColor:
    read = getBackgroundColor
    notify = backgroundColorChanged

  proc descriptionChanged*(self: CollectiblesEntry) {.signal.}
  proc getDescription*(self: CollectiblesEntry): string {.slot.} =
    if not self.hasCollectibleData() or isNone(self.getCollectibleData().description):
      return ""
    return self.getCollectibleData().description.get()

  QtProperty[string] description:
    read = getDescription
    notify = descriptionChanged

  proc collectionSlugChanged*(self: CollectiblesEntry) {.signal.}
  proc getCollectionSlug*(self: CollectiblesEntry): string {.slot.} =
    if not self.hasCollectionData():
      return ""
    return self.getCollectionData().slug

  QtProperty[string] collectionSlug:
    read = getCollectionSlug
    notify = collectionSlugChanged

  proc collectionNameChanged*(self: CollectiblesEntry) {.signal.}
  proc getCollectionName*(self: CollectiblesEntry): string {.slot.} =
    if self.hasCollectionData():
      result = self.getCollectionData().name
    if result == "":
      result = self.getContractAddress()

  QtProperty[string] collectionName:
    read = getCollectionName
    notify = collectionNameChanged

  proc collectionImageURLChanged*(self: CollectiblesEntry) {.signal.}
  proc getCollectionImageURL*(self: CollectiblesEntry): string {.slot.} =
    if not self.hasCollectionData():
      return ""
    return self.getCollectionData().imageUrl

  QtProperty[string] collectionImageUrl:
    read = getCollectionImageURL
    notify = collectionImageURLChanged

  proc traitsChanged*(self: CollectiblesEntry) {.signal.}
  proc getTraits*(self: CollectiblesEntry): QVariant {.slot.} =
    return newQVariant(self.traits)

  QtProperty[QVariant] traits:
    read = getTraits
    notify = traitsChanged

  proc ownershipChanged*(self: CollectiblesEntry) {.signal.}
  proc getOwnershipModel*(self: CollectiblesEntry): OwnershipModel =
    return self.ownership

  proc getOwnershipModelAsVariant*(self: CollectiblesEntry): QVariant {.slot.} =
    return newQVariant(self.ownership)

  QtProperty[QVariant] ownership:
    read = getOwnershipModelAsVariant
    notify = ownershipChanged

  proc communityIdChanged*(self: CollectiblesEntry) {.signal.}
  proc getCommunityId*(self: CollectiblesEntry): string {.slot.} =
    if not self.hasCommunityData():
      return ""
    return self.getCommunityData().id

  QtProperty[string] communityId:
    read = getCommunityId
    notify = communityIdChanged

  proc communityNameChanged*(self: CollectiblesEntry) {.signal.}
  proc getCommunityName*(self: CollectiblesEntry): string {.slot.} =
    if self.hasCommunityData():
      result = self.getCommunityData().name
    if result == "":
      result = self.getCommunityID()

  QtProperty[string] communityName:
    read = getCommunityName
    notify = communityNameChanged

  proc communityColorChanged*(self: CollectiblesEntry) {.signal.}
  proc getCommunityColor*(self: CollectiblesEntry): string {.slot.} =
    if not self.hasCommunityData():
      return ""
    return self.getCommunityData().color

  QtProperty[string] communityColor:
    read = getCommunityColor
    notify = communityColorChanged

  proc communityPrivilegesLevelChanged*(self: CollectiblesEntry) {.signal.}
  proc getCommunityPrivilegesLevel*(self: CollectiblesEntry): int {.slot.} =
    if not self.hasCommunityData():
      return PrivilegesLevel.Community.int
    return int(self.getCommunityData().privilegesLevel)

  QtProperty[int] communityPrivilegesLevel:
    read = getCommunityPrivilegesLevel
    notify = communityPrivilegesLevelChanged

  proc communityImageChanged*(self: CollectiblesEntry) {.signal.}
  proc getCommunityImage*(self: CollectiblesEntry): string {.slot.} =
    if not self.hasCommunityData() or isNone(self.getCommunityData().imageUrl):
      return ""
    return self.getCommunityData().imageUrl.get()

  QtProperty[string] communityImage:
    read = getCommunityImage
    notify = communityImageChanged

  proc getNetworkShortName*(self: CollectiblesEntry): string {.slot.} =
    return self.extradata.networkShortName

  QtProperty[string] networkShortName:
    read = getNetworkShortName

  proc getNetworkColor*(self: CollectiblesEntry): string {.slot.} =
    return self.extradata.networkColor

  QtProperty[string] networkColor:
    read = getNetworkColor

  proc getNetworkIconURL*(self: CollectiblesEntry): string {.slot.} =
    return self.extradata.networkIconURL

  QtProperty[string] networkIconUrl:
    read = getNetworkIconURL

  proc tokenTypeChanged*(self: CollectiblesEntry) {.signal.}
  proc getTokenType*(self: CollectiblesEntry): int {.slot.} =
    return self.tokenType.int

  QtProperty[int] tokenType:
    read = getTokenType
    notify = tokenTypeChanged

  proc soulboundChanged*(self: CollectiblesEntry) {.signal.}
  proc getSoulbound*(self: CollectiblesEntry): bool {.slot.} =
    if not self.hasCollectibleData() or isNone(self.getCollectibleData().soulbound):
      return false
    return self.getCollectibleData().soulbound.get()

  QtProperty[bool] soulbound:
    read = getSoulbound
    notify = soulboundChanged

  proc websiteChanged*(self: CollectiblesEntry) {.signal.}
  proc getWebsite*(self: CollectiblesEntry): string {.slot.} =
    if not self.hasCollectionData():
      return ""
    return self.getCollectionData().socials.website

  QtProperty[string] website:
    read = getWebsite
    notify = websiteChanged

  proc twitterHandleChanged*(self: CollectiblesEntry) {.signal.}
  proc getTwitterHandle*(self: CollectiblesEntry): string {.slot.} =
    if not self.hasCollectionData():
      return ""
    return self.getCollectionData().socials.twitterHandle

  QtProperty[string] twitterHandle:
    read = getTwitterHandle
    notify = twitterHandleChanged

  proc isMetadataValidChanged*(self: CollectiblesEntry) {.signal.}
  proc getIsMetaDataValid*(self: CollectiblesEntry): bool {.slot.} =
    return self.hasCollectibleData()

  QtProperty[bool] isMetadataValid:
    read = getIsMetaDataValid
    notify = isMetadataValidChanged

  proc updateDataIfSameID*(self: CollectiblesEntry, update: backend.Collectible): bool =
    if self.id != update.id:
      return false

    self.setData(update)

    # Notify changes for all properties
    self.nameChanged()
    self.imageUrlChanged()
    self.mediaUrlChanged()
    self.mediaTypeChanged()
    self.backgroundColorChanged()
    self.descriptionChanged()
    self.collectionSlugChanged()
    self.collectionNameChanged()
    self.collectionImageUrlChanged()
    self.traitsChanged()
    # Ownership doesn't change with updated data
    self.communityIdChanged()
    self.communityNameChanged()
    self.communityColorChanged()
    self.communityPrivilegesLevelChanged()
    self.communityImageChanged()
    return true

  proc contractTypeToTokenType(contractType: ContractType): TokenType =
    case contractType
    of ContractType.ContractTypeUnknown:
      return TokenType.Unknown
    of ContractType.ContractTypeERC20:
      return TokenType.ERC20
    of ContractType.ContractTypeERC721:
      return TokenType.ERC721
    of ContractType.ContractTypeERC1155:
      return TokenType.ERC1155
    else:
      return TokenType.Unknown

  proc newCollectibleDetailsFullEntry*(
      data: backend.Collectible, extradata: ExtraData
  ): CollectiblesEntry =
    new(result, delete)
    result.id = data.id
    result.setData(data)
    result.extradata = extradata
    result.generatedId = result.id.toString()
    result.generatedCollectionId = result.id.contractID.toString()
    result.tokenType =
      contractTypeToTokenType(data.contractType.get(ContractType.ContractTypeUnknown))
    result.setup()

  proc newCollectibleDetailsBasicEntry*(
      id: backend.CollectibleUniqueID, extradata: ExtraData
  ): CollectiblesEntry =
    new(result, delete)
    result.id = id
    result.extradata = extradata
    result.traits = newTraitModel()
    result.ownership = newOwnershipModel()
    result.generatedId = result.id.toString()
    result.generatedCollectionId = result.id.contractID.toString()
    result.setup()

  proc newCollectibleDetailsEmptyEntry*(): CollectiblesEntry =
    let id = backend.CollectibleUniqueID(
      contractID: backend.ContractID(chainID: 0, address: ""), tokenID: stint.u256(0)
    )
    let extradata = ExtraData()
    return newCollectibleDetailsBasicEntry(id, extradata)

  proc updateDataIfSameID*(
      self: CollectiblesEntry, update: backend.CollectionSocialsMessage
  ) =
    if self.id.contractID != update.id:
      return

    if not self.hasCollectionData():
      return

    self.getCollectionData().socials.website = update.socials.website
    self.getCollectionData().socials.twitterHandle = update.socials.twitterHandle

    # Notify changes for all properties
    self.twitterHandleChanged()
    self.websiteChanged()
